# AWS CloudFormation Template for Blaze Intelligence WebSocket Infrastructure
# Production-ready scaling with API Gateway WebSocket, Lambda, and DynamoDB

AWSTemplateFormatVersion: '2010-09-09'
Description: 'Blaze Intelligence - Production WebSocket Infrastructure'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues: [development, staging, production]
    Description: Environment name
  
  ProjectName:
    Type: String
    Default: blaze-intelligence
    Description: Project name for resource naming
  
  DomainName:
    Type: String
    Default: api.blaze-intelligence.com
    Description: Custom domain for WebSocket API

Resources:
  # DynamoDB Tables for connection and data storage
  ConnectionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-connections-${Environment}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
        - AttributeName: channel
          AttributeType: S
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: UserIndex
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: ChannelIndex
          KeySchema:
            - AttributeName: channel
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  GameDataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-gamedata-${Environment}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: gameId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
        - AttributeName: sport
          AttributeType: S
      KeySchema:
        - AttributeName: gameId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: SportIndex
          KeySchema:
            - AttributeName: sport
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # WebSocket API Gateway
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub '${ProjectName}-websocket-${Environment}'
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: $request.body.action
      Description: Blaze Intelligence WebSocket API for real-time sports data
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt ConnectionTable.Arn
                  - !GetAtt GameDataTable.Arn
                  - !Sub '${ConnectionTable.Arn}/index/*'
                  - !Sub '${GameDataTable.Arn}/index/*'
        - PolicyName: WebSocketApiAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:ManageConnections
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: '*'

  # Lambda Functions
  ConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-connect-${Environment}'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          CONNECTION_TABLE: !Ref ConnectionTable
          GAME_DATA_TABLE: !Ref GameDataTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            const userId = event.queryStringParameters?.userId || 'anonymous';
            const tier = event.queryStringParameters?.tier || 'starter';
            
            const timestamp = Math.floor(Date.now() / 1000);
            const ttl = timestamp + (30 * 60); // 30 minutes TTL
            
            try {
              await dynamodb.put({
                TableName: process.env.CONNECTION_TABLE,
                Item: {
                  connectionId,
                  userId,
                  tier,
                  connectedAt: timestamp,
                  ttl,
                  channels: []
                }
              }).promise();
              
              console.log(`Connection established: ${connectionId} for user ${userId}`);
              
              return {
                statusCode: 200,
                body: JSON.stringify({
                  message: 'Connected to Blaze Intelligence',
                  connectionId,
                  timestamp: Date.now(),
                  aiConsciousness: 87.6
                })
              };
            } catch (error) {
              console.error('Connection error:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({ error: 'Failed to connect' })
              };
            }
          };
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  DisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-disconnect-${Environment}'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          CONNECTION_TABLE: !Ref ConnectionTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            
            try {
              await dynamodb.delete({
                TableName: process.env.CONNECTION_TABLE,
                Key: { connectionId }
              }).promise();
              
              console.log(`Connection closed: ${connectionId}`);
              
              return {
                statusCode: 200,
                body: JSON.stringify({ message: 'Disconnected' })
              };
            } catch (error) {
              console.error('Disconnect error:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({ error: 'Failed to disconnect' })
              };
            }
          };
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  DefaultFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-default-${Environment}'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          CONNECTION_TABLE: !Ref ConnectionTable
          GAME_DATA_TABLE: !Ref GameDataTable
          WEBSOCKET_API_ENDPOINT: !Sub 'https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${WebSocketStage}'
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          const apigateway = new AWS.ApiGatewayManagementApi({
            endpoint: process.env.WEBSOCKET_API_ENDPOINT
          });
          
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            const body = JSON.parse(event.body || '{}');
            const action = body.action || 'ping';
            
            console.log(`Received action: ${action} from connection: ${connectionId}`);
            
            try {
              let response;
              
              switch (action) {
                case 'subscribe':
                  response = await handleSubscribe(connectionId, body.channel);
                  break;
                case 'unsubscribe':
                  response = await handleUnsubscribe(connectionId, body.channel);
                  break;
                case 'query':
                  response = await handleQuery(body);
                  break;
                case 'adjustConsciousness':
                  response = await handleConsciousnessAdjustment(body);
                  break;
                case 'ping':
                default:
                  response = { action: 'pong', timestamp: Date.now() };
              }
              
              await apigateway.postToConnection({
                ConnectionId: connectionId,
                Data: JSON.stringify(response)
              }).promise();
              
              return { statusCode: 200 };
            } catch (error) {
              console.error('Handler error:', error);
              return { statusCode: 500 };
            }
          };
          
          async function handleSubscribe(connectionId, channel) {
            // Add connection to channel
            await dynamodb.update({
              TableName: process.env.CONNECTION_TABLE,
              Key: { connectionId },
              UpdateExpression: 'ADD channels :channel',
              ExpressionAttributeValues: {
                ':channel': new Set([channel])
              }
            }).promise();
            
            return {
              action: 'subscribed',
              channel,
              timestamp: Date.now(),
              message: `Subscribed to ${channel}`
            };
          }
          
          async function handleUnsubscribe(connectionId, channel) {
            // Remove connection from channel
            await dynamodb.update({
              TableName: process.env.CONNECTION_TABLE,
              Key: { connectionId },
              UpdateExpression: 'DELETE channels :channel',
              ExpressionAttributeValues: {
                ':channel': new Set([channel])
              }
            }).promise();
            
            return {
              action: 'unsubscribed',
              channel,
              timestamp: Date.now()
            };
          }
          
          async function handleQuery(body) {
            // Simulate game query processing
            return {
              action: 'queryResult',
              queryId: body.queryId,
              result: {
                gameId: body.gameId,
                data: generateMockGameData(),
                processingTime: Math.random() * 100 + 50
              },
              timestamp: Date.now()
            };
          }
          
          async function handleConsciousnessAdjustment(body) {
            const { level, neuralSensitivity, predictionDepth } = body;
            
            return {
              action: 'consciousnessUpdated',
              consciousness: {
                level: Math.max(30, Math.min(100, level || 87.6)),
                neuralSensitivity: Math.max(30, Math.min(100, neuralSensitivity || 75)),
                predictionDepth: Math.max(40, Math.min(95, predictionDepth || 80)),
                lastAdjusted: Date.now()
              },
              timestamp: Date.now()
            };
          }
          
          function generateMockGameData() {
            return {
              games: [{
                id: 'game_' + Date.now(),
                home: 'DAL',
                away: 'PHI',
                score: { home: 24, away: 17 },
                quarter: 4,
                time: '8:42',
                winProbability: { home: 0.72, away: 0.28 }
              }]
            };
          }
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # Data Broadcasting Function (for real-time updates)
  BroadcastFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-broadcast-${Environment}'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          CONNECTION_TABLE: !Ref ConnectionTable
          GAME_DATA_TABLE: !Ref GameDataTable
          WEBSOCKET_API_ENDPOINT: !Sub 'https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${WebSocketStage}'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          const apigateway = new AWS.ApiGatewayManagementApi({
            endpoint: process.env.WEBSOCKET_API_ENDPOINT
          });
          
          exports.handler = async (event) => {
            console.log('Broadcasting real-time data updates');
            
            try {
              // Get all active connections
              const connections = await dynamodb.scan({
                TableName: process.env.CONNECTION_TABLE,
                ProjectionExpression: 'connectionId, channels'
              }).promise();
              
              // Generate real-time data
              const gameData = generateRealTimeData();
              
              // Broadcast to all connections
              const broadcastPromises = connections.Items.map(async (connection) => {
                try {
                  await apigateway.postToConnection({
                    ConnectionId: connection.connectionId,
                    Data: JSON.stringify({
                      action: 'dataUpdate',
                      data: gameData,
                      timestamp: Date.now()
                    })
                  }).promise();
                } catch (error) {
                  if (error.statusCode === 410) {
                    // Connection is stale, remove it
                    await dynamodb.delete({
                      TableName: process.env.CONNECTION_TABLE,
                      Key: { connectionId: connection.connectionId }
                    }).promise();
                  }
                  console.error(`Failed to send to ${connection.connectionId}:`, error);
                }
              });
              
              await Promise.allSettled(broadcastPromises);
              
              return {
                statusCode: 200,
                body: JSON.stringify({
                  message: 'Broadcast completed',
                  connectionCount: connections.Items.length,
                  timestamp: Date.now()
                })
              };
            } catch (error) {
              console.error('Broadcast error:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({ error: error.message })
              };
            }
          };
          
          function generateRealTimeData() {
            const consciousness = 87.6 + Math.sin(Date.now() / 10000) * 3.2;
            
            return {
              games: [{
                id: 'nfl_dal_phi_live',
                sport: 'NFL',
                home: 'DAL',
                away: 'PHI',
                score: { 
                  home: Math.floor(Math.random() * 10) + 20,
                  away: Math.floor(Math.random() * 10) + 15
                },
                quarter: Math.floor(Math.random() * 4) + 1,
                time: `${Math.floor(Math.random() * 15)}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`,
                winProbability: {
                  home: Math.random() * 0.4 + 0.4,
                  away: Math.random() * 0.4 + 0.2
                },
                lastUpdate: Date.now()
              }],
              insights: [{
                type: 'momentum',
                team: 'DAL',
                value: Math.random(),
                trend: ['increasing', 'decreasing', 'stable'][Math.floor(Math.random() * 3)],
                factors: ['Recent scoring drive', 'Defensive stop', 'Time of possession'],
                confidence: Math.random() * 0.3 + 0.7
              }],
              consciousness: {
                level: consciousness,
                fluctuation: Math.sin(Date.now() / 15000) * 2.5,
                neuralNodes: 25,
                synapses: 15
              }
            };
          }
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # EventBridge Rule for scheduled broadcasts
  BroadcastScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${ProjectName}-broadcast-schedule-${Environment}'
      Description: 'Schedule real-time data broadcasts'
      ScheduleExpression: 'rate(1 minute)'  # Broadcast every minute
      State: ENABLED
      Targets:
        - Arn: !GetAtt BroadcastFunction.Arn
          Id: BroadcastTarget

  BroadcastFunctionPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BroadcastFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt BroadcastScheduleRule.Arn

  # Lambda Permissions for API Gateway
  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ConnectFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref DisconnectFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  DefaultPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref DefaultFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  # API Gateway Routes
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      Target: !Sub 'integrations/${ConnectIntegration}'

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      Target: !Sub 'integrations/${DisconnectIntegration}'

  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $default
      Target: !Sub 'integrations/${DefaultIntegration}'

  # API Gateway Integrations
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectFunction.Arn}/invocations'

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DisconnectFunction.Arn}/invocations'

  DefaultIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DefaultFunction.Arn}/invocations'

  # API Gateway Stage
  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: !Ref Environment
      Description: !Sub 'Blaze Intelligence WebSocket API - ${Environment}'
      AutoDeploy: true
      DefaultRouteSettings:
        ThrottlingBurstLimit: 5000
        ThrottlingRateLimit: 2000
        DataTraceEnabled: true
        DetailedMetricsEnabled: true
        LoggingLevel: INFO
      AccessLogSettings:
        DestinationArn: !GetAtt WebSocketLogGroup.Arn
        Format: '$requestId $requestTime $identity.sourceIp $routeKey $status'
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName

  # CloudWatch Log Group for API Gateway
  WebSocketLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${ProjectName}-websocket-${Environment}'
      RetentionInDays: 14
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # CloudWatch Dashboard
  MonitoringDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${ProjectName}-${Environment}'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/ApiGateway", "Count", "ApiName", "${WebSocketApi}" ],
                  [ ".", "IntegrationLatency", ".", "." ],
                  [ ".", "Latency", ".", "." ]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "API Gateway Metrics"
              }
            },
            {
              "type": "metric",
              "x": 0,
              "y": 6,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/Lambda", "Duration", "FunctionName", "${ConnectFunction}" ],
                  [ ".", ".", ".", "${DisconnectFunction}" ],
                  [ ".", ".", ".", "${DefaultFunction}" ],
                  [ ".", ".", ".", "${BroadcastFunction}" ]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "Lambda Performance"
              }
            }
          ]
        }

Outputs:
  WebSocketApiId:
    Description: 'WebSocket API Gateway ID'
    Value: !Ref WebSocketApi
    Export:
      Name: !Sub '${ProjectName}-websocket-api-id-${Environment}'

  WebSocketUrl:
    Description: 'WebSocket API URL'
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${ProjectName}-websocket-url-${Environment}'

  ConnectionTableName:
    Description: 'DynamoDB Connection Table Name'
    Value: !Ref ConnectionTable
    Export:
      Name: !Sub '${ProjectName}-connection-table-${Environment}'

  GameDataTableName:
    Description: 'DynamoDB Game Data Table Name'
    Value: !Ref GameDataTable
    Export:
      Name: !Sub '${ProjectName}-gamedata-table-${Environment}'

  DashboardUrl:
    Description: 'CloudWatch Dashboard URL'
    Value: !Sub 'https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${ProjectName}-${Environment}'
    Export:
      Name: !Sub '${ProjectName}-dashboard-url-${Environment}'