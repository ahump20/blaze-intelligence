<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blaze Intelligence - Babylon.js Championship Platform</title>
    <meta name="description" content="Next-gen sports analytics with WebGPU ray tracing and procedural generation">

    <!-- Babylon.js CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>

    <!-- Blaze Intelligence Styles -->
    <style>
        :root {
            --burnt-orange: #BF5700;
            --cardinal-blue: #9BCBEB;
            --tennessee-deep: #002244;
            --vancouver-teal: #00B2A9;
            --championship-gold: #FFD700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #002244 100%);
            color: #E5E7EB;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 2rem;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
            z-index: 100;
            pointer-events: none;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .title-section {
            flex: 1;
        }

        .title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--burnt-orange) 0%, var(--championship-gold) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--cardinal-blue);
            font-weight: 500;
        }

        .stats-panel {
            display: flex;
            gap: 2rem;
            background: rgba(0, 34, 68, 0.6);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 16px;
            border: 1px solid rgba(155, 203, 235, 0.3);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            color: var(--championship-gold);
            font-variant-numeric: tabular-nums;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.25rem;
        }

        .controls {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 100;
        }

        .btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--burnt-orange), var(--vancouver-teal));
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(191, 87, 0, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .performance-badge {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(0, 34, 68, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(155, 203, 235, 0.3);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            z-index: 100;
        }

        .performance-badge .fps {
            color: var(--championship-gold);
            font-weight: 700;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0e27 0%, #002244 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 4px solid rgba(191, 87, 0, 0.1);
            border-top-color: var(--burnt-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 2rem;
            font-size: 1.2rem;
            color: var(--cardinal-blue);
        }
    </style>

    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#BF5700">
    <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw-pwa.js');
      }
    </script>
  <link rel="preload" href="/css/blaze-professional.css" as="style">
    <link rel="preload" href="/js/navigation-manager.js" as="script">
    <link rel="preload" href="/images/brand/blaze-hero.png" as="image">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://api.sportsdataio.com">
  </head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">Initializing Championship Platform...</div>
    </div>

    <!-- Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="overlay">
        <div class="header">
            <div class="title-section">
                <h1 class="title">BLAZE INTELLIGENCE</h1>
                <p class="subtitle">WebGPU Ray Tracing • Procedural Generation • Championship Analytics</p>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-value" id="winRate">94.6%</div>
                    <div class="stat-label">Win Rate</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="dataPoints">2.8M+</div>
                    <div class="stat-label">Data Points</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="latency">&lt;100ms</div>
                    <div class="stat-label">Latency</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="accuracy">97.2%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="btn" onclick="toggleVisualization('neural')">Neural Network</button>
        <button class="btn" onclick="toggleVisualization('stadium')">Stadium View</button>
        <button class="btn" onclick="toggleVisualization('data')">Data Streams</button>
        <button class="btn" onclick="toggleRayTracing()">Toggle Ray Tracing</button>
    </div>

    <!-- Performance Monitor -->
    <div class="performance-badge">
        <div>FPS: <span class="fps" id="fps">60</span></div>
        <div>Engine: <span id="engineType">WebGL2</span></div>
        <div>Ray Tracing: <span id="rtStatus">OFF</span></div>
    </div>

    <!-- Babylon.js Implementation -->
    <script src="js/babylon-converter.js"></script>
    <script src="js/babylon-enhanced-visualizer.js"></script>
    <script>
        // Global variables
        let visualizer = null;
        let converter = null;
        let currentVisualization = 'neural';
        let rayTracingEnabled = false;

        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            const canvas = document.getElementById('renderCanvas');
            const loadingScreen = document.getElementById('loadingScreen');

            try {
                // Initialize converter
                converter = new BabylonConverter();
                const engine = await converter.initializeEngine(canvas, {
                    rayTracing: true
                });

                // Update engine type display
                document.getElementById('engineType').textContent =
                    converter.isWebGPUSupported ? 'WebGPU' : 'WebGL2';

                // Create scene
                converter.createScene();
                converter.setupLighting();

                // Create visualizations
                await createChampionshipScene();

                // Hide loading screen
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                }, 1000);

                // Start render loop
                converter.startRenderLoop(() => {
                    updateStats();
                });

                // Setup FPS counter
                setInterval(updateFPS, 1000);

            } catch (error) {
                console.error('Failed to initialize:', error);
                loadingScreen.innerHTML = `
                    <div style="color: #ff4444;">Failed to initialize. Please refresh.</div>
                `;
            }
        });

        // Create championship scene
        async function createChampionshipScene() {
            // Create neural network
            const network = createNeuralNetwork();

            // Create procedural stadium
            const stadium = converter.createProceduralStadium('mlb', 'cardinals');
            stadium.setEnabled(false);

            // Create data streams
            const dataStreams = createDataStreams();
            dataStreams.setEnabled(false);

            // Create particle effects
            converter.createHeroParticles();

            // Animate camera
            animateCamera();
        }

        // Create neural network visualization
        function createNeuralNetwork() {
            const network = new BABYLON.Mesh('neuralNetwork', converter.scene);

            // Create interconnected nodes
            const layers = [4, 6, 6, 4];
            const nodes = [];

            layers.forEach((count, layerIndex) => {
                const layerNodes = [];
                for (let i = 0; i < count; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere(`node_${layerIndex}_${i}`, {
                        diameter: 2,
                        segments: 32
                    }, converter.scene);

                    const x = (layerIndex - 1.5) * 15;
                    const y = (i - count / 2) * 4;

                    sphere.position = new BABYLON.Vector3(x, y, 0);

                    // PBR material
                    const material = new BABYLON.PBRMaterial(`nodeMat_${layerIndex}_${i}`, converter.scene);
                    material.albedoColor = layerIndex === 0 ? converter.colors.burntOrange :
                                          layerIndex === layers.length - 1 ? converter.colors.cardinalBlue :
                                          converter.colors.vancouverTeal;
                    material.metallic = 0.4;
                    material.roughness = 0.3;
                    material.emissiveColor = material.albedoColor;
                    material.emissiveIntensity = 0.5;

                    sphere.material = material;
                    sphere.parent = network;
                    layerNodes.push(sphere);

                    // Animate
                    animateNode(sphere, i * 0.2);
                }
                nodes.push(layerNodes);
            });

            // Create connections
            for (let l = 0; l < nodes.length - 1; l++) {
                nodes[l].forEach(node1 => {
                    nodes[l + 1].forEach(node2 => {
                        createConnection(node1, node2, network);
                    });
                });
            }

            return network;
        }

        // Create connection between nodes
        function createConnection(node1, node2, parent) {
            const path = [node1.position, node2.position];
            const tube = BABYLON.MeshBuilder.CreateTube('connection', {
                path: path,
                radius: 0.1,
                tessellation: 8
            }, converter.scene);

            const material = new BABYLON.PBRMaterial('connectionMat', converter.scene);
            material.albedoColor = converter.colors.cardinalBlue;
            material.emissiveColor = converter.colors.cardinalBlue;
            material.emissiveIntensity = 0.3;
            material.alpha = 0.6;

            tube.material = material;
            tube.parent = parent;

            // Animate data flow
            const animation = new BABYLON.Animation(
                'dataFlow',
                'material.emissiveIntensity',
                30,
                BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
            );

            animation.setKeys([
                { frame: 0, value: 0.1 },
                { frame: 15, value: 0.8 },
                { frame: 30, value: 0.1 }
            ]);

            tube.material.animations = [animation];
            converter.scene.beginAnimation(tube.material, 0, 30, true, Math.random() + 0.5);

            return tube;
        }

        // Animate node
        function animateNode(node, delay) {
            const animationGroup = new BABYLON.AnimationGroup('nodeAnimation', converter.scene);

            // Scale animation
            const scaleAnimation = new BABYLON.Animation(
                'scale',
                'scaling',
                30,
                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
            );

            scaleAnimation.setKeys([
                { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                { frame: 30, value: new BABYLON.Vector3(1.3, 1.3, 1.3) },
                { frame: 60, value: new BABYLON.Vector3(1, 1, 1) }
            ]);

            // Rotation animation
            const rotationAnimation = new BABYLON.Animation(
                'rotation',
                'rotation.y',
                30,
                BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
            );

            rotationAnimation.setKeys([
                { frame: 0, value: 0 },
                { frame: 120, value: Math.PI * 2 }
            ]);

            animationGroup.addTargetedAnimation(scaleAnimation, node);
            animationGroup.addTargetedAnimation(rotationAnimation, node);

            setTimeout(() => {
                animationGroup.play(true);
            }, delay * 1000);
        }

        // Create data streams
        function createDataStreams() {
            const streams = new BABYLON.Mesh('dataStreams', converter.scene);

            for (let i = 0; i < 3; i++) {
                const path = [];

                for (let t = 0; t < Math.PI * 4; t += 0.2) {
                    path.push(new BABYLON.Vector3(
                        Math.cos(t) * (10 + i * 5),
                        t * 2 - 10,
                        Math.sin(t) * (10 + i * 5)
                    ));
                }

                const ribbon = BABYLON.MeshBuilder.CreateTube(`stream${i}`, {
                    path: path,
                    radius: 0.5 + i * 0.2,
                    tessellation: 32,
                    cap: BABYLON.Mesh.CAP_ALL
                }, converter.scene);

                const material = new BABYLON.PBRMaterial(`streamMat${i}`, converter.scene);
                const colors = [
                    converter.colors.cardinalsRed,
                    converter.colors.titansNavy,
                    converter.colors.grizzliesNavy
                ];

                material.albedoColor = colors[i];
                material.emissiveColor = colors[i];
                material.emissiveIntensity = 0.5;
                material.alpha = 0.7;
                material.metallic = 0.5;
                material.roughness = 0.3;

                ribbon.material = material;
                ribbon.parent = streams;

                // Animate
                const animation = new BABYLON.Animation(
                    `streamAnim${i}`,
                    'rotation.y',
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );

                animation.setKeys([
                    { frame: 0, value: 0 },
                    { frame: 180, value: Math.PI * 2 }
                ]);

                ribbon.animations = [animation];
                converter.scene.beginAnimation(ribbon, 0, 180, true, 0.3 + i * 0.1);
            }

            return streams;
        }

        // Animate camera
        function animateCamera() {
            const camera = converter.camera;
            const radius = 40;
            let angle = 0;

            converter.scene.registerBeforeRender(() => {
                angle += 0.002;
                camera.position.x = Math.cos(angle) * radius;
                camera.position.z = Math.sin(angle) * radius;
                camera.position.y = 15 + Math.sin(angle * 2) * 5;
                camera.setTarget(BABYLON.Vector3.Zero());
            });
        }

        // Toggle visualization
        function toggleVisualization(type) {
            const meshes = converter.scene.meshes;

            // Hide all
            meshes.forEach(mesh => {
                if (mesh.name.includes('neural') ||
                    mesh.name.includes('stadium') ||
                    mesh.name.includes('stream')) {
                    mesh.setEnabled(false);
                }
            });

            // Show selected
            switch(type) {
                case 'neural':
                    meshes.filter(m => m.name.includes('neural') || m.name.includes('node') || m.name.includes('connection'))
                          .forEach(m => m.setEnabled(true));
                    break;
                case 'stadium':
                    meshes.filter(m => m.name.includes('stadium') || m.name.includes('diamond') || m.name.includes('wall'))
                          .forEach(m => m.setEnabled(true));
                    break;
                case 'data':
                    meshes.filter(m => m.name.includes('stream'))
                          .forEach(m => m.setEnabled(true));
                    break;
            }

            currentVisualization = type;
        }

        // Toggle ray tracing
        function toggleRayTracing() {
            rayTracingEnabled = !rayTracingEnabled;

            if (converter.isWebGPUSupported) {
                if (rayTracingEnabled) {
                    converter.setupRayTracing();
                    document.getElementById('rtStatus').textContent = 'ON';
                } else {
                    // Disable ray tracing effects
                    const pipeline = converter.scene.postProcessRenderPipelineManager.supportedPipelines[0];
                    if (pipeline) {
                        pipeline.screenSpaceReflectionsEnabled = false;
                        pipeline.motionBlurEnabled = false;
                    }
                    document.getElementById('rtStatus').textContent = 'OFF';
                }
            } else {
                alert('Ray tracing requires WebGPU support. Please use a compatible browser.');
            }
        }

        // Update FPS
        function updateFPS() {
            const fps = converter.engine.getFps();
            document.getElementById('fps').textContent = Math.round(fps);
        }

        // Update stats
        function updateStats() {
            // Animate stat values
            const winRate = 94.6 + Math.sin(Date.now() * 0.001) * 2;
            document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';

            const accuracy = 97.2 + Math.cos(Date.now() * 0.0008) * 1.5;
            document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (converter && converter.engine) {
                converter.engine.resize();
            }
        });
    </script>

</body></html>